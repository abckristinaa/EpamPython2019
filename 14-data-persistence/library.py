import json
import pickle
import os
from abc import ABC, abstractmethod


class Storage(ABC):
    """ Defines essential interface for all kind of storages. """
    @abstractmethod
    def save_to_library(self, file, protocol, filename):
        pass

    @abstractmethod
    def read_from_library(self, file, protocol, filename):
        pass


class FileStorage:
    """ Provides interface to work with file storage.

    Methods:
        """
    @staticmethod
    def save(file: str, protocol: str, filename: str) -> None:
        """ Saves a file to library using the given serialization protocol. """
        if protocol.lower() == 'json':
            flag, protocol = 'w', json
        elif protocol.lower() == 'pickle':
            flag, protocol = 'wb', pickle
        else:
            raise ValueError("Unknown protocol")

        with open(filename, flag) as f:
            protocol.dump(file, f)

        path_to_file = os.getcwd() + '/' + filename
        if os.path.exists(path_to_file):
            print('\nФайл успешно создан: ', path_to_file)
        else:
            print('\nЧто-то пошло не так. Файл не создан.')

    @staticmethod
    def read(file: str, protocol: str, filename):
        """ Returns a file from file storage available to read. """
        if protocol.lower() == 'json':
            flag, protocol = 'r', json
        elif protocol.lower() == 'pickle':
            flag, protocol = 'rb', pickle
        else:
            raise ValueError("Unknown protocol")

        with open(file, flag) as f:
            filename = protocol.load(f)
        return filename


'''class PostgresStorage(Storage):
    def __init__(self, postgres_conn):
        self.postgres_conn = postgres_conn

    def get(self, serialization, out_table):
        conn = psycopg2.connect(**self.postgres_conn)

        def json_f():
            cur = conn.cursor()
            cur.execute(
                f"SELECT c_json from {out_table}")
            rows = cur.fetchone()[0]
            cur.close()
            conn.commit()
            conn.close()
            return rows

        def pickle_f():
            cur = conn.cursor()
            cur.execute(
                f"SELECT c_pickle from {out_table}")
            rows = cur.fetchone()[0]
            cur.close()
            conn.commit()
            conn.close()
            return pickle.loads(rows)

        return self.check_exec_serial(serialization, json_f, pickle_f)

    def set(self, inp_obj, serialization, out_table):
        conn = psycopg2.connect(**self.postgres_conn)

        def json_f():
            cur = conn.cursor()
            cur.execute(
                f"""CREATE TABLE if not exists {out_table} 
                (id INT GENERATED BY DEFAULT AS IDENTITY,
                 c_json json)
                """)
            cur.execute(f"DELETE FROM {out_table}")
            cur.execute(
                """INSERT INTO {1} (  c_json ) VALUES ( '{0}' ) """.format(
                    json.dumps(inp_obj), out_table))
            cur.close()
            conn.commit()
            conn.close()

        def pickle_f():
            cur = conn.cursor()
            cur.execute(f"""CREATE TABLE if not exists {out_table} 
                       (id INT GENERATED BY DEFAULT AS IDENTITY, c_pickle bytea)
                       """)
            cur.execute(f"DELETE FROM {out_table}")
            pickle_obj = pickle.dumps(inp_obj)
            cur.execute(f"""INSERT INTO {out_table}  (c_pickle) VALUES (%s)""",
                        (pickle_obj,))
            cur.close()
            conn.commit()
            conn.close()

        self.check_exec_serial(serialization, json_f, pickle_f)


class MongoStorage(Storage):
    def __init__(self, mongo_connection):
        self.mongo_connection = mongo_connection
        self.my_database = mongo_connection.epam

    def get(self, serialization, out_table):
        def json_f():
            json_collection = self.my_database[out_table]
            unserial = list(json_collection.find())[0]['json_serial']
            return json.loads(unserial)

        def pickle_f():
            pickle_collection = self.my_database[out_table]
            unserial = list(pickle_collection.find())[0]['pickle_serial']
            return pickle.loads(unserial)

        return self.check_exec_serial(serialization, json_f, pickle_f)

    def set(self, inp_obj, serialization, out_table):
        def json_f():
            json_collection = self.my_database[out_table]
            json_collection.delete_one({})
            json_collection.insert_one(
                {"json_serial": json.dumps(inp_obj)})

        def pickle_f():
            pickle_collection = self.my_database[out_table]
            pickle_collection.delete_one({})
            pickle_collection.insert_one(
                {"pickle_serial": pickle.dumps(inp_obj)})

        self.check_exec_serial(serialization, json_f, pickle_f)'''

if __name__ == "__main__":
    FileStorage.save("hw.txt", "pickle", "new_file")
    FileStorage.read("new_file", "pickle", "new_file.txt")
